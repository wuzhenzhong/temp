# NodeJS架构 - 单线程事件循环模型

12018.12.17 14:46:39字数 2805阅读 483



![img](https://upload-images.jianshu.io/upload_images/5318700-4b08e1b5e6f80f2a.png?imageMogr2/auto-orient/strip|imageView2/2/w/802/format/webp)

Event Loop

这篇译章探究了NodeJS的架构和单线程事件循环模型。我们将在本文中讨论“NodeJS如何在底层工作，它遵循什么类型的处理模型，NodeJS如何使用单线程模型处理并发请求”等内容。

### **NodeJS 单线程事件循环模型**

正如我们刚才说的，NodeJS使用的是“单线程事件循环模型”的架构去处理多个并发的客户端请求的。

有许多Web应用程序技术，如JSP，Spring MVC，ASP.NET等。但所有这些技术都遵循“多线程请求 - 响应”架构来处理多个并发客户端。

我们已经熟悉“多线程请求 - 响应”架构，因为它被大多数Web应用程序框架使用。 但是为什么NodeJS选择了不同的架构来开发Web应用程序。多线程和单线程事件循环体系结构之间的主要区别是什么?

### **NodeJS**

NodeJS使用“单线程事件循环模型”架构来处理多个并发客户端。然而它是如何真正处理并发客户端请求且不使用多个线程。什么是事件循环模型？我们将逐一讨论这些概念。

在讨论“单线程事件循环”架构之前，首先我们将介绍著名的“多线程请求 - 响应”架构。

### **传统的Web应用处理模型**

任何非NodeJS开发的Web应用程序通常都遵循“多线程请求 - 响应”模型。我们可以将此模型称为请求/响应模型。

客户端向服务器发送请求，然后服务器根据客户端请求进行一些处理，准备响应并将其发送回客户端。

该模型使用HTTP协议。由于HTTP是无状态协议，因此该请求/响应模型也是无状态模型。所以我们可以将其称为请求/响应无状态模型。

但是，此模型使用多线程来处理并发客户端请求。 在讨论这个模型内部之前，首先要看下面的内容。

#### **请求/响应模型处理的步骤:**

- 客户端发送一个请求到Web服务器
- Web服务器内部维护一个有限的线程池，以便在客户端请求提供服务
- Web服务器处于无限循环中并等待客户端传入请求
- Web服务器处理请求步骤:
  - 接收到一个客户端请求
  - 从线程池中选择一个线程
  - 将此线程分配给客户端请求
  - 此线程读取客户端请求，处理客户端请求，执行阻塞的IO操作(如果需要)和准备响应
  - 此线程将准备好的请求发送回Web服务器
  - Web服务器又将此响应发送到相应的服务器

服务器为所有客户端执行以上步骤，为每一个客户端请求创建一个线程。

![请求/响应模型](http://static.zybuluo.com/leeahui424/lrm201l1nlrg9sr9m8gv27e2/image_1cutcp1m0gp2j98s0lglemcq2j.png)

请求/响应模型

**图表说明:**

- Client-1, Client-2, ..., Client-n是同时发送请求到Web服务器的客户端应用
- Web服务器内部维护着一个有限的线程池，线程池中线程数量为m个
- Web服务器逐个接收这些请求:
  - Web服务器拾取Client-1的请求Request-1，从线程池中拾取一个线程T-1并将此请求分配给线程T-1
    - 线程T-1读取Client-1的请求Request-1, 并处理该请求
    - 该请求无阻塞IO处理
    - 处理完必要的步骤后准备将Response-1发送回客户端
    - Web服务器又将此Response-1发送到Client-1
  - Web服务器拾取Client-2的请求Request-2，从线程池中拾取一个线程T-2并将此请求分配给线程T-2
    - 线程T-2读取Client-2的请求Request-2, 并处理该请求
    - 该请求无阻塞IO处理
    - 处理完必要的步骤后准备将Response-2发送回客户端
    - Web服务器又将此Response-2发送到Client-2
  - Web服务器拾取Client-n的请求Request-n，从线程池中拾取一个线程T-n并将此请求分配给线程T-n
    - 线程T-n读取Client-n的请求Request-n, 并处理该请求
    - Request-n需要大量的阻塞IO和计算操作
    - 线程T-n需要更多时间与外部系统(SQL, File System)交互，执行必要步骤并准备Response-n并将其发送回服务器
    - Web服务器又将此Response-n发送到Client-n

如果'n'大于'm'（大多数时候,它是真的），则在使用完所有的m个线程之后，剩余的客户端请求会在队列中等待。

如果这些线程中有大量的阻塞IO操作(例如:和数据库、文件系统、外部服务等交互)，那么剩余的客户端也会等待更长的时间。

- 一旦线程池中的线程空闲且可用于下一个任务，服务器就会拾取这些线程并将它们分配给剩余的客户端请求。
- 每个线程都会使用到许多资源，如内存等。因此，在将这些线程从忙状态转到等待状态之前，它们应该释放所有获取的资源。

**请求/响应无状态模型的缺点：**

- 在处理越来越多的并发客户端请求时会变得棘手
- 当客户端请求增加时，线程也会越来越多，最后它们会占用更多内存。
- 客户端可能需要等待服务器释放可用的线程去处理其请求
- 处理阻塞式的IO任务时浪费时间

### **NodeJS的架构 - 单线程事件循环**

NodeJS不遵循请求/响应多线程无状态模型。 它采用单线程与事件循环模型。 NodeJS的处理模型主要基于Javascript基于事件的模型和Javascript回调机制。

因为NodeJS遵循的架构，它可以非常轻松地处理越来越多的并发客户端请求。 在讨论这个模型内部之前，首先要看下面的图表。

我试图设计这个图来解释NodeJS内部的每一点。

NodeJS的处理模型主要核心是“事件循环(Event Loop)”。如果我们理解这一点，那么很容易理解NodeJS的内部架构的。

#### **单线程事件循环模型的处理步骤**

- 客户端发送请求到Web服务器
- NodeJS的Web服务器在内部维护一个有限的线程池，以便为客户端请求提供服务
- NodeJS的Web服务器接收这些请求并将它们放入队列中。 它被称为“事件队列”
- NodeJS的Web服务器内部有一个组件，称为“事件循环”，它使用无限循环来接收请求并处理它们。
- 事件循环只使用到了一个线程，它是NodeJS的处理模型的核心
- 事件循环回去检查是否有客户端的请求被放置在事件队列中。如果没有，会一直等待事件队列中存在请求。
- 如果有，则会从事件队列中拾取一个客户端请求：
  - 开始处理客户端请求
  - 如果该客户端请求不需要任何阻塞IO操作，则处理所有内容，准备响应并将其发送回客户端
  - 如果该客户端请求需要一些阻塞IO操作，例如与数据库，文件系统，外部服务交互，那么它将遵循不同的方法:
    - 从内部线程池检查线程可用性
    - 获取一个线程并将此客户端请求分配给该线程
    - 该线程负责接收该请求，处理该请求，执行阻塞IO操作，准备响应并将其发送回事件循环
    - 事件循环依次将响应发送到相应的客户端

![单线程事件循环模型](http://static.zybuluo.com/leeahui424/tfjj2y1swy87e6wz9f0p10ou/image_1cutcnc389lhdfq160g31734o26.png)

单线程事件循环模型

**图表说明:**

- Client-1, Client-2, ..., Client-n是同时发送请求到Web服务器的客户端应用
- Web服务器内部维护着一个有限的线程池，线程池中线程数量为m个
- NodeJS的Web服务器接收到Client-1, Client-2, ..., Client-n的请求后，将请求放入到事件队列中
- NodeJS的事件循环从队列中开始拾取这些请求:
  - 事件循环拾取Client-1的请求Request-1
    - 检查Client-1 Request-1是否确实需要任何阻塞IO操作，或者需要更多时间来执行复杂的计算任务
    - 由于此请求是简单计算和非阻塞IO任务，因此不需要单独的线程来处理它
    - 事件循环处理该请求所需要的操作，准备其响应Response-1
    - 事件循环发送Response-1到Client-1
  - 事件循环拾取Client-2的请求Request-2
    - 检查Client-2 Request-2是否需要任何阻塞IO操作或花费更多时间来执行复杂的计算任务
    - 由于此请求是简单计算和非阻塞IO任务，因此不需要单独的线程来处理它
    - 事件循环处理该请求所需要的操作，准备其响应Response-2
    - 事件循环发送Response-2到Client-2
  - 事件循环拾取Client-n的请求Request-n
    - 检查Client-n Request-n是否需要任何阻塞IO操作或花费更多时间来执行复杂的计算任务
    - 由于此请求有非常复杂的计算或阻塞IO任务，因此事件循环不会处理此请求
    - 事件循环从内部线程池中获取线程T-1，并将此Client-n Request-n分配给线程T-1
    - 线程T-1读取并处理Request-n，执行必要的阻塞IO或计算任务，最后准备响应Response-n
    - 线程T-1将此Response-n发送到事件循环
      事件循环依次将此Response-n发送到Client-n

此处客户端请求是对一个或多个JavaScript函数的调用，因为JavaScript函数可以调用其他函数或可以利用其回调函数性质。

此所以每个客户端的请求处理都看起来向这样:

![回调函数调用](http://static.zybuluo.com/leeahui424/5x4j8u3gc5qab5c1mtbvvyat/image_1cutdfvm737b30o1het1f5mloh30.png)

回调函数调用

例如:

```javascript
function1(function2,callback1);
function2(function3,callback2);
function3(input-params);
```

**NodeJS的单线程事件循环的优势**

- 处理越来越多的并发客户端请求非常容易
- 因为事件循环的存在，即使我们的NodeJS应用接收到了越来越多的并发请求，我们也不需要去新建很多的线程
- NodeJS使用到了较少的线程，所以资源和内存的使用较少