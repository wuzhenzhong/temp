# 更新

SqlSugar更新分为2大类写法，1种是传实体对象的方式 这种是以实体对象为核心进行更新，不传实体对象这种是以表达式为核心进行更新

```cs
`//传实体对象写法（支持批量对象）``db.Updateable(updateObj) ` `//不传实体对象写法``db.Updateable<T>()`
```

**传对象的用法**

根据实体更新（主键要有值，主键是更新条件）

```cs
`var` `t1 = db.Updateable(updateObj).ExecuteCommand(); ``//这种方式会以主键为条件`
```

4.2.3添加了WhereColumns 虽然XId不是主键但是 XId作为更新条件

```cs
`var` `t1 = db.Updateable(updateObj).WhereColumns(it=>``new``{it.XId}).ExecuteCommand();``//单列可以用 it=>it.XId` `//需要注意 当WhereColumns和UpdateColumns一起用时，需要把wherecolumns中的列加到UpdateColumns中``var` `update = db.Updateable(updateObj).UpdateColumns(s => ``new` `{ s.RowStatus,s.Id }).WhereColumns(it => ``new` `{ it.Id });`
```



只更新实体里面的Name列(主键要有值，主键是更新条件)

```cs
`var` `t3 = db.Updateable(updateObj).UpdateColumns(it => ``new` `{ it.Name }).ExecuteCommand();`
```



更新 Name和 TestId 以外的所有列 (主键要有值，主键是更新条件)

```cs
`var` `t4 = db.Updateable(updateObj)``.IgnoreColumns(it => ``new` `{ it.Name, it.TestId }).ExecuteCommand();`
```



更新NAME 以外的所有列

```cs
`var` `t5 = db.Updateable(updateObj)``.IgnoreColumns(it => it==``"name"` `).ExecuteCommand(); ``//name列不更新`  `var` `t5 = db.Updateable(updateObj)``.IgnoreColumns(it => list.Contains(it)  ).ExecuteCommand(); ``//List中所有列不更新`
```



使用锁

```cs
`var` `t6 = db.Updateable(updateObj).With(SqlWith.UpdLock).ExecuteCommand();`
```



批量更新(主键要有值，主键是更新条件)

```cs
`List<Students> list=GetList();``var` `t7 = db.Updateable(list).ExecuteCommand();`
```



实体更新，并且给Name重新赋值 ，其它列也会更新

```cs
`var` `t8 = db.Updateable(updateObj)``.ReSetValue(it => it.Name == (it.Name + 1)).ExecuteCommand();`
```



只更新Name并且 Name的值等于Name+1, 如果updateObj值为NULL一定要加WHERE才可以

```cs
`//写法1``var` `t8 = db.Updateable(updateObj)``.UpdateColumns(it=>``new` `{it.Name}).ReSetValue(it => it.Name == (it.Name + 1)).ExecuteCommand();`
```

第一种updateable()有参数的，下面二种是没参数的注意下区别



更新实体，更新条件是根据表达式

```cs
`var` `t9 = db.Updateable(updateObj).Where(it => it.Id == 1).ExecuteCommand();`
```



是NULL的列不更新

```cs
`db.Updateable(updateObj).IgnoreColumns(ignoreAllNullColumns:``true``).ExecuteCommand();`
```



4.6.4.8 版本支持了不需要泛型的字典

```cs
`//如果initKey.Systemtable方是写法``var` `dt = ``new` `Dictionary<``string``,``object``>();``dt.Add(``"id"``, 1);``dt.Add(``"name"``, ``"1"``);``var` `t66 = db.Updateable(dt).AS(``"student"``).ExecuteCommand();``//UPDATE STUDENT  SET  NAME=@name  WHERE ID=@ID` `//如果initkey.Attribute方式是拿不出主键信息的需要写成这样``var` `dt = ``new` `Dictionary<``string``,``object``>();``dt.Add(``"id"``, 1);``dt.Add(``"name"``, ``"1"``);``var` `t66 = db.Updateable(dt).AS(``"student"``).WhereColumns(``"id"``).With(SqlWith.UpdLock).ExecuteCommand()``//没有WhereColumns(string)去下载最新的` `//也支持List<Dictionary<string,object>>`
```



4.2.2 更新 匿名对象和字典的支持

```cs
` ``var` `t13 = db.Updateable<Student>(``new` `{ Name = ``"a"``, id=1 }).ExecuteCommand();`` ``//UPDATE [STudent]  SET [Name]='a' WHERE [Id]=1`` ``var` `t14 = db.Updateable<Student>(``new` `Dictionary<``string``, ``object``>() { { ``"id"``, 1 }, { ``"name"``, ``"a"` `} }).ExecuteCommand();`` ``//UPDATE [STudent]  SET [Name]='a' WHERE [Id]=1`
```





**不传对象的用法**

根据表达式中的列更新   ，只更新 Name和CreateTime 条件是id=11，比较常用

```cs
`//正确写法`` ``var` `t10 = db.Updateable<Student>()``.UpdateColumns(it => ``new` `Student() { Name = ``"a"``, CreateTime = DateTime.Now })``.Where(it => it.Id == 11).ExecuteCommand();` `//错误写法``var` `st=``new` `Student() { Name = ``"a"``, CreateTime = DateTime.Now };``var` `t10 = db.Updateable<Student>()``.UpdateColumns(it => st)``.Where(it => it.Id == 11).ExecuteCommand();`
```



别名表

```cs
`db.Updateable<School>().AS(``"Student"``)``.UpdateColumns(it => ``new` `School() { Name = ``"jack"` `})``.Where(it => it.Id == 1).ExecuteCommand();``//Update Student set Name='jack' Where Id=1`
```



4.6.0.7 联表更新



```cs
`var` `t17 = db.Updateable<Student>().UpdateColumns(it => ``       ``new` `Student(){``        ``SchoolId = SqlFunc.Subqueryable<School>().Where(s => s.Id == it.SchoolId).Select(s => s.Id),``        ``Name = ``"newname"``       ``}).Where(it => it.Id == 1).ExecuteCommand();`
```

```cs
UPDATE [STudent]  SET
            [SchoolId] = (SELECT TOP 1 [Id] FROM [School] WHERE ( [Id] =[STudent].[SchoolId] )) , 
            [Name] = @Const0   WHERE ( [ID] = @Id1 )
```



只更新Name并且 Name的值等于Name+1

```cs
`//写法1``var` `t8 = db.Updateable<Student>().UpdateColumns(it => ``new` `Student() { Name = it.Name+1}).Where(it => it.Id == 11).ExecuteCommand();` `//写法2 (注意：4.5.9.8以上版本支持) 如果只有一列可以简化成这种写法 ``var` `t8= db.Updateable<Student>().UpdateColumns(it => it.Name == it.Name+1).Where(it => it.Id == 11).ExecuteCommand();`
```





**技巧功能**

```cs
`//根据不同条件执行更新不同的列``var` `t3 = db.Updateable(updateObj)``                ``.UpdateColumnsIF(caseValue==``"1"``,it => ``new` `{ it.Name })``                ``.UpdateColumnsIF(caseValue==``"2"``, it => ``new` `{ it.Name,it.CreateTime })``                ``.ExecuteCommand();`
```



# 更新对数据的 版本控制



例如我想验证我表单传过来的数据在数据库是否是最新的版本，不是最新版本抛出提示，

参考这个DEMO



https://github.com/sunkaixuan/SqlSugar/blob/dev/Src/Asp.Net/SqlServerTest/Demos/F_VersionValidation.cs