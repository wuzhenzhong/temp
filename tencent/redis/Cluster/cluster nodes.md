# cluster nodes（集群节点）

```javascript
CLUSTER NODES
```

**自3.0.0起可用。**

**时间复杂度：** O（N）其中N是 Cluster 节点的总数

[纠错](javascript:;)

Redis 集群中的每个节点都有其当前集群配置的视图，由已知节点的集合给出，我们与这些节点的连接状态，它们的标志，属性和分配的槽等等。

CLUSTER NODES 以串行格式提供所有这些信息，即我们正在联系的节点的当前集群配置，该格式恰好与 Redis Cluster 自身使用的格式相同，以便在磁盘上存储集群状态（但磁盘群集状态在最后附加了一些附加信息）。

请注意，通常情况下，希望在 Cluster 哈希槽和节点地址之间获取映射的客户端应该使用 CLUSTER SLOTS。提供更多信息的 CLUSTER NODES 应该用于管理任务，调试和配置检查。它也用于`redis-trib`管理群集。

## 序列化格式

命令的输出只是一个空格分隔的 CSV 字符串，其中每行代表集群中的一个节点。以下是输出示例：

```javascript
07c37dfeb235213a872192d90877d0cd55635b91 127.0.0.1:30004 slave e7d1eecce10fd6bb5eb35b9f99a514335d9ba9ca 0 1426238317239 4 connected
67ed2db8d677e59ec4a4cefb06858cf2a1a89fa1 127.0.0.1:30002 master - 0 1426238316232 2 connected 5461-10922
292f8b365bb7edb5e285caf0b7e6ddc7265d2f4f 127.0.0.1:30003 master - 0 1426238318243 3 connected 10923-16383
6ec23923021cf3ffec47632106199cb7f496ce01 127.0.0.1:30005 slave 67ed2db8d677e59ec4a4cefb06858cf2a1a89fa1 0 1426238316232 5 connected
824fe116063bc5fcf9f4ffd895bc17aee7731ac3 127.0.0.1:30006 slave 292f8b365bb7edb5e285caf0b7e6ddc7265d2f4f 0 1426238317741 6 connected
e7d1eecce10fd6bb5eb35b9f99a514335d9ba9ca 127.0.0.1:30001 myself,master - 0 0 1 connected 0-5460
```

每行由以下字段组成：

```javascript
<id> <ip:port> <flags> <master> <ping-sent> <pong-recv> <config-epoch> <link-state> <slot> <slot> ... <slot>
```

每个字段的含义如下：

\1. `id`：节点 ID，一个40个字符的随机字符串，当一个节点被创建时不会再发生变化（除非`CLUSTER RESET HARD`被使用）。

\2. `ip:port`：客户端应该联系节点以运行查询的节点地址。

\3. `flags`：逗号列表分隔的标志：`myself`，`master`，`slave`，`fail?`，`fail`，`handshake`，`noaddr`，`noflags`。标志在下一节详细解释。

\4. `master`：如果节点是从属节点，并且主节点已知，则节点ID为主节点，否则为“ - ”字符。

\5. `ping-sent`：以毫秒为单位的当前激活的ping发送的unix时间，如果没有挂起的ping，则为零。

\6. `pong-recv`：毫秒 unix 时间收到最后一个乒乓球。

\7. `config-epoch`：当前节点（或当前主节点，如果该节点是从节点）的配置时期（或版本）。每次发生故障切换时，都会创建一个新的，唯一的，单调递增的配置时期。如果多个节点声称服务于相同的哈希槽，则具有较高配置时期的节点将获胜。

\8. `link-state`：用于节点到节点集群总线的链路状态。我们使用此链接与节点进行通信。可以是`connected`或`disconnected`。

\9. `slot`：散列槽号或范围。从参数9开始，但总共可能有16384个条目（限制从未达到）。这是此节点提供的散列槽列表。如果条目仅仅是一个数字，则被解析为这样。如果它是一个范围，它是在形式`start-end`，并且意味着节点负责所有散列时隙从`start`到`end`包括起始和结束值。

标志的含义（字段编号3）：

- `myself`：您正在联系的节点。

- `master`：节点是主人。

- `slave`：节点是从属的。

- `fail?`：节点处于`PFAIL`状态。对于正在联系的节点无法访问，但仍然可以在逻辑上访问（不处于`FAIL`状态）。

- `fail`：节点处于`FAIL`状态。对于将`PFAIL`状态提升为`FAIL`的多个节点而言，这是无法访问的。

- `handshake`：不受信任的节点，我们握手。

- `noaddr`：此节点没有已知的地址。

- `noflags`：根本没有标志。

## 注意发布的配置时期

奴隶广播他们的主人的配置纪元（为了得到一个`UPDATE`消息，如果他们被发现是陈旧的），所以奴隶的真正配置时代（多少没有意义，因为他们不提供散列槽）只能是获得检查标记为的节点`myself`，这是我们要求生成 CLUSTER NODES 输出的节点的条目。其他从属时期反映了它们在心跳包中发布的内容，即它们当前正在复制的主时间的配置时期。

## 特殊插槽条目

通常，与给定节点相关联的散列槽是以下格式之一，如上所述：

\1. Single number: 3894

\2. Range: 3900-4000

但是，节点散列槽可以处于特殊状态，用于在节点重新启动后发送错误（AOF / RDB文件中的键与节点散列槽配置不匹配），或者存在重新分片操作时。这两个国家正在**进口**和**迁移**。

Redis 规范解释了这两种状态的含义，但是这两种状态的要点如下：

- **导入**插槽尚未成为节点散列槽的一部分，因此正在进行迁移。只有在使用`ASK`命令的情况下，节点才会接受有关这些插槽的查询。

- **迁移**插槽将分配给该节点，但正在迁移到某个其他节点。如果命令中的所有键已经存在，节点将接受查询，否则它将发出所谓的 **ASK重定向**，以直接在导入节点中强制创建新键。

导入和迁移插槽在 CLUSTER NODES 输出中发出，如下所示：

- **导入插槽：** `[slot_number-<-importing_from_node_id]`

- **迁移插槽：** `[slot_number->-migrating_to_node_id]`

以下是导入和迁移插槽的几个示例：

- `[93-<-292f8b365bb7edb5e285caf0b7e6ddc7265d2f4f]`

- `[1002-<-67ed2db8d677e59ec4a4cefb06858cf2a1a89fa1]`

- `[77->-e7d1eecce10fd6bb5eb35b9f99a514335d9ba9ca]`

- `[16311->-292f8b365bb7edb5e285caf0b7e6ddc7265d2f4f]`

请注意，该格式没有任何空格，因此 CLUSTER NODES 输出格式为纯 CSV 格式，即使在发布此特殊插槽时也会以空格作为分隔符。然而，一个完整的格式解析器应该能够处理它们。

注意：

\1. 迁移和导入插槽仅添加到标记为的节点`myself`。该信息对于其自己的插槽是本地的节点。

\2. 导入和迁移插槽作为**附加信息**提供。如果节点具有指定的给定散列槽，则它也将是散列槽列表中的普通数字，因此对散列槽迁移没有线索的客户端可以跳过这些特殊字段。

## 返回值

[批量字符串回复](https://redis.io/topics/protocol#bulk-string-reply)：序列化群集配置。

本文档系腾讯云云+社区成员共同维护，如有问题请联系 yunjia_community@tencent.com

最后更新于：2017-12-18